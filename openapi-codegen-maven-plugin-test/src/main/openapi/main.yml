openapi: 3.0.0
info:
    
  version: '1.0-alpha'

  title: EGC API

  ## Note that description fields may use Common Markdown 
  ## (supported by OpenApi 3)
 
  description: | 
    # EGC API
    
    ## Design considerations
    
    ### Two-phase send
    
    Sending a new MSI is two-phase (create then send). This is
    because the msiId value is a critical piece of information
    for the client (to be able to check status and/or cancel)
    and the API design must ensure that the client is safely 
    in possession of msiID before a send happens. If the 
    method was one phase then there would be no guarantee that
    the msiID was received (a failure could happen in any link
    in the return snetworking chain like a router, firewall, proxy 
    server or indeed a problem at the client application end
    that prevented persistence of the msiID for later use).
    Moreover, if the method was one phase and a failure in the
    network chain occurred then not only would an orphan MSI 
    be sent by the provider but the client would not have
    knowledge that the MSI had been successfully queued for
    sending and would naturally retry the send (multiple times
    even) and we end up with the same MSI being sent 2+ times.
    
    To further clarify the problem being solved by a two phase
    send here is a [discussion](https://stackoverflow.com/questions/49444723/how-to-make-sure-the-http-response-was-delivered) 
    of the delivery guarantees of HTTP responses. 
    
    Note that a one phase call where the client generated a new 
    unique id (using a UUID for instance) is a possible solution 
    but is less desirable because it introduces a problematic 
    edge case where the client accidentally uses the same id more
    than once. If two different messages are sent with the same id
    (concurrently even) then the service should ensure that only 
    one message is accepted and that the service consumer is aware 
    that the other message failed. To do this demands coordination
    with a single transactional resource (like a relational database) which 
    also demands that that resource is highly available (relational 
    databases are often not great at that during upgrade cycles). There 
    are ways to get high availability (highly available cloud services like 
    DynamoDB and many more can offer conditional updates) but there is
    a much simpler way with two-phase. 
    
    If instead of the one-phase call the server creates the msiId and communicates 
    it to the client then the server side can potentially be scaled
    with ease if the msiID is a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) 
    for instance (which is effectively unique without coordination
    with other nodes). 
    
    For example, a highly available and scalable 
    service could be constructed in AWS cloud using API Gateway with
    Lambda integrations that for the create message and send actions
    does this
    
      * **Create:** Generate a new UUID, place the message content and UUID on 
    to a queue for processing , return the UUID
      * **Send:** Place the UUID parameter on to a queue for processing
    
    A separate component then actions items on the queue(s). When both 
    the send and create messages have been read then an actual send can take 
    place. What is clear from this design is that many concurrent nodes could
    be receiving messages without coordinating with a central node/service 
    to ensure id uniqueness.
    
    Note also that to support two-phase send the status value of
     `CREATED` is included.
    
    ### Pagination
    
    The List MSIs action uses a paginated response as the number of 
    MSIs in a response can get large. Pagination can reduce server
    overhead and improve response times. Client-driven pagination is 
    where the client specifies an offset (skip) field and that number
    of rows is skipped by the server to return the next page. This
    can be inefficient for the server-side (see [discussion](
    https://use-the-index-luke.com/no-offset)) and it is preferred to 
    use server-driven pagination which is where each page returned 
    also includes a continuation token to be included in the next page 
    call. The nice thing about this approach is that the server side
    can simply return an offset in the continuation token if desired but 
    we enable more efficient techniques if wanted later.
    
    ### Client specific identifiers
    
    Early versions of this API have suggested the inclusion of a 
    `NationalSASId` field in the created MSI with the purpose of allowing 
    a client to correlate an MSI with its internal data. 
    
    This field is a convenience only and thus theoretically should not be
    included. A client should manage its correlations itself by storing the
    unique msiId returned by the service paired with its internal identifiers. 
    
    If something is required then it should be labelled something 
    like `tag` and have arbitrary values so that the client can use it for 
    anything. Labelling it `NationalSASId` suggests more meaning to the
    field than it may have. **TODO** confirm.
    
    ### Geometry
    
    Note that the api below allows for float precision locations for 
    geographic circles and rectangles. An implementation of this API 
    may choose to use the location with reduced precision (for example
    lat longs rounded to nearest integer).
    
    ### Cancellation
    
    A PUT to an `/msi/[id}` path ]with content like `{"isCancelled":true}` 
    has been suggested as a way of cancelling a broadcast. This can be 
    achieved in a much simpler way with the DELETE verb without content 
    (a cancel action can be considered as a logical delete in the context
    of this API). A cancelled broadcast cannot be changed in status but 
    can be queried. 
    
    ### Abstraction of C-Codes
    
    Initial proposals for the API suggested a partial abstraction of C-Codes. 
    In particular Priority, MsiType and AreaType were abstracted. This API 
    demonstrates a full abstraction of C-Codes. It is equivalent to C-Codes
    but has an easier to read and process representation and the mapping to C-Codes 
    then becomes a server-side implementation detail. By using the data modelling
    constructs of OpenAPI v3 and JSON Schema users can generate code for their 
    API-consuming application that imposes compile-time checking (varies on language)
    instead of experiencing runtime failures.
    
    **TODO** is there a requirement for full explicit C-Code support (zero 
    abstraction)?
    
    ### Auth
    
    Initial proposals for this API included a re-authenticate 
    method whereby a new token was returned if a currently valid token was 
    supplied. This is a security hole in that anyone in possession of one 
    valid token (but not the username and password) can stay authenticated 
    forever. In the same vein, a sensible limit on validity duration of a 
    token should be imposed so that a leaked token cannot be used for long. 
    Given the likely usage of the API (in terms of the number of calls made
    in a time interval by a client) there should be no significant performance
    penalty forcing a refresh of the token each hour (or even less).
    
    Bearer authentication is used ([RFC6750](https://www.rfc-editor.org/rfc/rfc6750.html#page-5)).
    Bearer authentication is carried in the `Authorization` request header in this format:
    
        Authorization: Bearer BASE64_ENCODED_TOKEN
    
    **TODO** The encoded content of the token is not defined (for example, JWT could be used)
    but is left to the implementer. Should the authentication flow follow an existing 
    standard like OAuth 2.0? 
    
    ### Naming
    Previous API drafts used the field names `startDate` and `endDate` for an MSI.
    Given that those fields refer to timestamps not just dates the names `startTime`
    and `endTime` have been used.
    
    ### Acknowledgments
    Iridium can at times provide receive and read acknowledgements. **TODO** get 
    better documentation of the capability and a proper specification for their
    response from a list acks call.
    
    ### Timings
    There may be use cases for the following additional fields on an MSI:
    
    * createdTime
    * cancelledTime
    
    A user could record in their own systems when they created or cancelled a broadcast 
    but it might help problem diagnosis if that information was together.
    
    **TODO** confirm
    
    It would also be useful in some circumstances for users to know exactly when a
    message was broadcast by satellite. Although messages may be scheduled for 
    immediate or later broadcast there may be significant delays till the broadcast
    occurs and the user should be able to see the actual broadcast times.
    
    **TODO** discuss with satellite providers

servers:
  - url: https://myservice.com/v1
    
paths:

  /authenticate:

    ###############################################
    ## Authenticate
    ###############################################   
    post:
      operationId: getToken
      summary: Authenticate
      description: |
        Obtains a token that will be passed in a request header to calls
        to other paths on this API for authentication and authorization
        purposes.
      requestBody:
        description: | 
          username and password
        required: true
        content:
          application/json: 
            schema:
              $ref: '#/components/schemas/AuthenticationRequestBody'
      responses:
        '200':    
          description: token and expiry time
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/AuthenticationResponse' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '500':    
          $ref: '#/components/responses/ServerError'              
  
  /msi:
  
    ###############################################
    ## Create an MSI
    ###############################################      
    post:
      operationId: createMsi
      summary: Create MSI
      description: |
        Submits message content and returns a unique id (across all 
        users) that is to be used in the send method. It is ok for
        a message to never be sent but the provider should have the 
        freedom to clean up (delete) unsent messages after some 
        reasonable period or after more than N unsent messages are created.
        (**TODO** ask providers what is reasonable minimum period and 
        maximum number of unsent messages so it can be documented here). 
      requestBody:
        description: |
          Describes the message content
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MsiContent'
      responses:
        '201':    
          description: The unique identifier of the newly created MSI
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/MsiId' 
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'
      security: 
      - bearer: []
                
    ###############################################
    ## List MSIs
    ###############################################      
    get:
      operationId: getMsis
      summary: List MSIs
      description: |
        Returns Maritime Safety Information broadcasts requested to
        be sent by the user. 
        
        Note that none of the parameters are required. If no parameters
        are supplied then all MSIs for the current user will be returned
        (paged).
        
        The `limit` field may not be honoured exactly by the server
        side (in that it might exceed a maximum limit of the server).
        
        The results of this query may return in any order and that order
        may vary in repeated calls (for example, the returned MSIs *may* 
        not be ordered by timestamp). If the client requires an ordering
        by time then all pages should be requested and then sorted 
        client-side. **TODO** confirm expectations
      parameters:
        - in: query
          name: startTimeMin
          description: | 
            If startTimeMinInclusive is true (the default value if not specified)
            then filters MSIs on startTime >= startTimeMin.
            
            If startTimeMinInclusive is false then filters MSIs
            on startTime > startTimeMin.
          schema:
            type: string
            format: date-time
            example: '2022-04-20T18:25:43.511Z' 
        - in: query
          name: startTimeMinInclusive
          description: |
            If startTimeMinInclusive is true (the default value if not specified)
            then filters MSIs on startTime >= startTimeMin.
            
            If startTimeMinInclusive is false then filters MSIs
            on startTime > startTimeMin.
            
            If startTimeMinInclusive not specified then has no effect.
          schema:
            type: boolean
            default: true
            example: true
        - in: query
          name: startTimeMax
          description: |
            If startTimeMaxInclusive is true (the default value if not specified)
            then filters MSIs on startTime <= startTimeMax.
            
            If startTimeMaxInclusive is false then filters MSIs
            on startTime < startTimeMax.
          schema:
            type: string
            format: date-time
            example: '2022-04-24T23:25:43.511Z'
        - in: query
          name: startTimeMaxInclusive
          description: |
            If startTimeMaxInclusive is true (the default value if not specified)
            then filters MSIs on startTime <= startTimeMax.
            
            If startTimeMaxInclusive is false then filters MSIs
            on startTime < startTimeMax.
            
            If startTimeMaxInclusive not specified then has no effect.
          schema:
            type: boolean
            default: true
            example: true
        - in: query
          name: endTimeMin
          description: | 
            If endTimeMinInclusive is true (the default value if not specified)
            then filters MSIs on startTime >= startTimeMin.
            
            If startTimeMinInclusive is false then filters MSIs
            on startTime > startTimeMin.
          schema:
            type: string
            format: date-time
            example: '2022-04-21T18:25:43.511Z'
        - in: query
          name: endTimeMinInclusive
          description: |
            If endTimeMinInclusive is true (the default value if not specified)
            then filters MSIs on endTime >= endTimeMin.
            
            If endTimeMinInclusive is false then filters MSIs
            on endTime > endTimeMin.
            
            If endTimeMinInclusive not specified then has no effect.
          schema:
            type: boolean
            example: true 
        - in: query
          name: endTimeMax
          description: |
            If endTimeMaxInclusive is true (the default value if not specified)
            then filters MSIs on endTime <= endTimeMax.
            
            If endTimeMaxInclusive is false then filters MSIs
            on endTime < endTimeMax.
          schema:
            type: string
            format: date-time
            example: '2022-04-25T14:18:23.000Z'
        - in: query
          name: endTimeMaxInclusive
          description: |
            If endTimeMaxInclusive is true (the default value if not specified)
            then filters MSIs on endTime <= endTimeMax.
            
            If endTimeMaxInclusive is false then filters MSIs
            on endTime < endTimeMax.
            
            If endTimeMaxInclusive not specified then has no effect.
          schema:
            type: boolean
            default: true
            example: true             
        - in: query
          name: limit
          description: |
            Requests that at most `limit` MSIs are returned in the call.
            The server may cap the requested `limit` (fewer items may be
            returned). To request the next page available include the 
            returned `continuationToken` in the next call. If there are 
            no more items available then the response will not contain
            a `continuationToken`.
          schema:
            type: integer
            format: int32
            minimum: 1
            default: 10
        - in: query
          name: status
          description: |
            Only MSIs that have a status in the given list
            are returned. If the list is empty (or the parameter
            is not present) then no filtering on status occurs.
            **TODO** support multi-status filtering or just one?
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Status'
            example:
            - CREATED
            - CANCELLED
        - in: query
          name: broadcastType
          description: the type of broadcast
          schema:
            $ref: '#/components/schemas/BroadcastType' 
        - in: query
          name: continuationToken
          description: |
            Describes to the server the starting point of 
            the next page of results and is obtained from 
            the current page. May contain an offset if desired
            but is at the discretion of implementer. Note that
            it is possible that a call specifying a continuation
            token may return en empty list (but an empty list return 
            should not have a continuation token on it so at 
            that point paging would stop).
          schema:
            $ref: '#/components/schemas/ContinuationToken' 
        ## review other fields, acks etc.
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema:
                description: |
                  A list of MSIs and an optional continuation token (
                  to retrieve the next page of MSIs). If the list of
                  MSIs is empty there should be no continuation token. 
                type: object
                properties:
                  msis:
                    type: array
                    items: 
                      $ref: '#/components/schemas/Msi'
                  continuationToken:
                    $ref: '#/components/schemas/ContinuationToken'
                required: [msis]
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'          
        '500':    
          $ref: '#/components/responses/ServerError'
      security: 
      - bearer: []
                
  /msi/{id}:
    
    parameters:
      - $ref: '#/components/parameters/MsiId'
    
    ###############################################
    ## Get an MSI
    ############################################### 
    get:
      operationId: getMsi
      summary: Get MSI
      description: |
        Returns the details of an MSI broadcast using the unique MSI identifier.
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/Msi'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'          
        '500':    
          $ref: '#/components/responses/ServerError'
      security: 
      - bearer: []
      

    ###############################################
    ## Send an MSI
    ###############################################      
    put:
      operationId: sendMsi
      summary: Send MSI
      description: |
        Requests that an existing unsent MSI be sent. If the MSI 
        has already been sent or the MSI has been cancelled then 
        nothing occurs (this method is idempotent). 
      responses:
        '204':    
          description: OK
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'    
        '404':
          $ref: '#/components/responses/NotFound'                
        '500':    
          $ref: '#/components/responses/ServerError'
      security: 
      - bearer: []                        

    ###############################################
    ## Cancel an MSI
    ############################################### 
    delete:
      operationId: cancelMsi
      summary: Cancel MSI 
      description: |
        This is a logical delete of a broadcast in that it
        prevents future broadcasts happening for this msiId
        (be it a single or repeating broadcast). Once cancelled
        an MSI cannot be resent. However, the broadcast details 
        are still available to be queried.
      responses:
        '204':    
          description: OK (No Content)
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'   
        '404':
          $ref: '#/components/responses/NotFound'                 
        '500':    
          $ref: '#/components/responses/ServerError'       
      security: 
      - bearer: []

  /msi/{id}/status:
    
    parameters:
      - $ref: '#/components/parameters/MsiId'
    
    ###############################################
    ## Get the status of an MSI
    ############################################### 
    get:
      operationId: getMsiStatus
      summary: Get status of an MSI
      description: |
        Returns the status of an MSI broadcast using the unique MSI identifier.
      responses:
        '200':    
          description: OK
          content:
            application/json:
              schema: 
                $ref: '#/components/schemas/Status'
        '400':    
          $ref: '#/components/responses/BadRequest'
        '401': 
          $ref: '#/components/responses/Unauthorized'
        '403': 
          $ref: '#/components/responses/Forbidden'
        '404':
          $ref: '#/components/responses/NotFound'          
        '500':    
          $ref: '#/components/responses/ServerError'
      security: 
      - bearer: []
                                     
components:
  securitySchemes:
    bearer:
      type: http
      scheme: bearer
      description: |
        As per RFC6750: `Authorization: Bearer BASE_64_ENCODED_TOKEN`
       
  parameters:
    MsiId:
      in: path
      name: id
      schema:
        $ref: '#/components/schemas/MsiId'
      description: unique msi identifier
      required: true
        
  responses:
    BadRequest:
      description: Bad request
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'

    NotFound:
      description: Resource Not Found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'            
            
    Unauthorized:
      description: Unauthorized (must authenticate)
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
            
    Forbidden:
      description: Not allowed
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                                    
    ServerError:
      description: Unexpected error on the server
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
                      
  schemas:
    Error:
      description: an error message (response)
      type: object
      properties:
        ## all properties optional
        statusCode: 
          type: integer
          format: int32
          minimum: 100
          maximum: 599
        errorMessage: 
          type: string
          example: an error occurred
        errorType:
          type: string
        stackTrace:
          type: array
          items: 
            type: string
        cause:
          $ref: '#/components/schemas/Error' 
      example:
        errorMessage: an error occurred
        errorType: SomethingWentWrongException

    AuthenticationRequestBody:
      description: |
        Holds the credentials and validity preference used to 
        create a token to be passed as a request header in calls
        to the API
      type: object
      properties:
        username:
          type: string
          minLength: 1
          example: myrcc
        password:
          type: string
          minLength: 1
          example: a-nice-strong-password
        validityMinutes:
          description: | 
            The duration in minutes that the token will be valid, 
            capped by the maximum allowed server-decided duration.  
            If not supplied (this parameter is optional) then the
            server default will be applied. Either way the response
            from this method supplies the expiry time for the
            token. The token should be refreshed before the expiry 
            time to avoid auth related failures. Note that this field
            is only a suggestion to the service and may be ignored.
          type: integer
          format: int32
          minimum: 1
          example: 60
      required: [username, password]
      example:
        username: myrcc
        password: a-nice-strong-password
        validityMinutes: 60
        
    AuthenticationResponse:
      type: object
      properties:
        token: 
          type: string
          minLength: 1
          example: '1/mZ1edKKACtPAb7zGlwSzvs72PvhAbGmB8K1ZrGxpcNM'
        expiryTime:
          type: string
          format: date-time
          description: |
            An expiryTime should always accompany the token
            because a requested validity duration may be 
            capped by the server and the client needs to know 
            what the resultant expiry time was.
          example: '2022-04-23T18:25:43.511Z'
      required: [token, expiryTime]
        
    MsiId:
      type: string
      minLength: 1
      maxLength: 255
      example: 289ee192-fdf5-4070-befc-3bf7291c1386
      
    SARPriority:
      type: string
      enum: [SAFETY, URGENCY, DISTRESS]
      example: SAFETY
    
    NonSARPriority:
      type: string
      enum: [SAFETY, URGENCY]
      example: URGENCY
      
    Status:
      type: string
      enum: [CREATED, SCHEDULED, ACTIVE, FINISHED, CANCELLED]
      example: ACTIVE
      
    BroadcastType:
      type: string
      enum: [SARBroadcast, MetBroadcast, NavBroadcast, PiracyBroadcast]
      example: SARBroadcast
      
    Payload:
      description: |
        the ASCII message text to broadcast. **TODO** what max length is appropriate?
      type: string
      minLength: 1
      maxLength: 65535 ## TODO what max length is appropriate?
      example: a message to be broadcast 

    Latitude:
      type: number
      format: float
      minimum: -90
      maximum: 90
      example: -45.5
      
    Longitude:
      type: number
      format: float
      minimum: -180
      maximum: 180
      example: 145.44
      
    Circle:
      type: object
      properties:
        lat:
          $ref: '#/components/schemas/Latitude' 
        lon:
          $ref: '#/components/schemas/Longitude' 
        radiusNm:
          type: number
          format: float
          minimum: 0
      required: [lat, lon, radiusNm]
      
    Rectangle:
      type: object
      properties: 
        minLat: 
          $ref: '#/components/schemas/Latitude'
        leftLon: 
          $ref: '#/components/schemas/Longitude' 
        heightDegrees:
          type: number
          format: float
          minimum: 0
          exclusiveMinimum: true
          maximum: 180
        widthDegrees:
          type: number
          format: float
          minimum: 0
          exclusiveMinimum: true
          maximum: 360
      required: [minLat, leftLon, heightDegrees, widthDegrees]
                
    Geometry:
      oneOf:
      - $ref: '#/components/schemas/Rectangle'
      - $ref: '#/components/schemas/Circle'
      example:
        lat: -42.5
        lon: 135.884
        radiusNm: 100.5
        
    Broadcast:
      description: the details of the broadcast particular to the broadcast type
      oneOf:
      - $ref: '#/components/schemas/SARBroadcast'
      - $ref: '#/components/schemas/MetBroadcast'
      - $ref: '#/components/schemas/NavBroadcast'
      - $ref: '#/components/schemas/PiracyBroadcast'
      example:
        sarArea: 
          lat: -34.5
          lon: 145.44
          radiusNm: 150
        priority: SAFETY
                
    MsiContent:
      type: object
      description: |
        Used to create a new MSI. `repetition` is optional. If omitted
        once only is assumed (no repetition). `startTime` and
        `endTime` are optional fields and 0, 1 or both can be
        present.
      properties:
        broadcast:
          $ref: '#/components/schemas/Broadcast'
        startTime:
          type: string
          format: date-time
          description: the scheduled time of the initial broadcast
          example: '2022-04-23T10:30:43.511Z'
        endTime:
          type: string
          format: date-time
          description: |
            the time after which no more broadcasts should be made
            of this MSI 
          example: '2022-04-24T10:25:43.511Z'
        payload: 
          $ref: '#/components/schemas/Payload'   
        echo: 
          description: |
            If the satellite provider supports echo then setting this field to true
            will request a repeat broadcast is made a short time after the first 
            (Inmarsat applies a 6 minute interval). Consult the satellite provider
            documentation about under what circumstances the echo will be honoured.
          type: boolean
          default: false        
        repetition:
          $ref: '#/components/schemas/Repetition'
        readAcksEnabled:
          description: |
            If the satellite provider supports read acknowledgements then setting this 
            field to true will enable acknowledgements to the satellite provider
            that the message has been read by the receiving vessel.
          type: boolean
          example: false
        receiveAcksEnabled:
          description: |
            If the satellite provider supports receive acknowledgements then setting this 
            field to true will enable acknowledgements to the satellite provider
            that the message has been received by the vessel.
          type: boolean
          example: false 
      ## repetition is optional
      required: [broadcast, payload]
        
    Msi:
      type: object
      description: |
        Represents a created MMSI (with an identifier).
        
        `repetition` is optional. If omitted once only is assumed
        (no repetition). `startTime` and `endTime`
        are optional fields and 0, 1 or both can be present.
      properties:
        id: 
          $ref: '#/components/schemas/MsiId'
        broadcast:
          $ref: '#/components/schemas/Broadcast'
        createdTime:
          type: string
          format: date-time
          description: |
            when the MSI was created
          example: '2022-04-23T10:25:43.511Z'
        cancelledTime:
          type: string
          format: date-time
          description: |
            when the MSI was cancelled. This field should be set
            if the status is CANCELLED.
          example: '2022-04-24T13:28:43.511Z'
        startTime:
          type: string
          format: date-time
          description: |
            Start time of the broadcast schedule
          example: '2022-04-23T10:30:43.511Z'
        endTime:
          type: string
          format: date-time
          description: |
            End time of the broadcast schedule
          example: '2022-04-24T10:25:43.511Z'
        payload: 
          $ref: '#/components/schemas/Payload'
        status:
          $ref: '#/components/schemas/Status' 
        echo: 
          description: |
            If the satellite provider supports echo then setting this field to true
            will request a repeat broadcast is made a short time after the first 
            (Inmarsat applies a 6 minute interval). Consult the satellite provider
            documentation about under what circumstances the echo will be honoured.
          type: boolean
          default: false     
        repetition:
          $ref: '#/components/schemas/Repetition'
        readAcksEnabled:
          description: |
            If the satellite provider supports read acknowledgements then setting this 
            field to true will enable acknowledgements to the satellite provider
            that the message has been read by the receiving vessel.
          type: boolean
          example: false
        receiveAcksEnabled:
          description: |
            If the satellite provider supports receive acknowledgements then setting this 
            field to true will enable acknowledgements to the satellite provider
            that the message has been received by the vessel.
          type: boolean
          example: false 
      ## repetition is optional
      required: [id, broadcast, payload, createdTime, startTime, endTime, status]
        
    SARBroadcast:
      type: object
      description: |
        area is optional. If omitted then corresponds to the
        entire coverage area.
      properties: 
        sarArea:
          $ref: '#/components/schemas/SARBroadcastArea'
        serviceType:
          $ref: '#/components/schemas/SARServiceType'
        priority:
          $ref: '#/components/schemas/SARPriority'
      required: [priority, serviceType]
          
    SARBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/NavArea'
      
    SARServiceType:
      type: string
      enum: [SHORE_TO_SHIP_DISTRESS_ALERT, SAR_COORDINATION, SHORE_TO_SHIP_URGENCY_OR_SAFETY, GENERAL]
         
    MetBroadcast:
      type: object
      properties:
        area:
          $ref: '#/components/schemas/MetBroadcastArea' 
        priority:
          $ref: '#/components/schemas/NonSARPriority'
      required: [area, priority]
      
    MetBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/MetArea'
      - $ref: '#/components/schemas/MetCoastalWarningArea'
        
    NavBroadcast:
      type: object
      properties:
        ## need to differentiate from PiracyBroadcast so that 
        ## oneOf resolution works
        navBroadcastArea:
          $ref: '#/components/schemas/NavOrPiracyBroadcastArea' 
        priority:
          $ref: '#/components/schemas/NonSARPriority'
      required: [navBroadcastArea, priority]    
      
    PiracyBroadcast:
      type: object
      properties:
        piracyBroadcastArea:
          $ref: '#/components/schemas/NavOrPiracyBroadcastArea' 
        priority:
          $ref: '#/components/schemas/NonSARPriority'
      required: [piracyBroadcastArea, priority]    
        
    NavOrPiracyBroadcastArea:
      oneOf:
      - $ref: '#/components/schemas/Geometry'
      - $ref: '#/components/schemas/NavArea'
      - $ref: '#/components/schemas/NavCoastalWarningArea'
              
    NavArea:
      properties: 
        navAreaCode:
          $ref: '#/components/schemas/NavAreaCode'
      required: [navAreaCode] 
          
    NavAreaCode:
      type: integer
      format: int32
      minimum: 1
      maximum: 21
          
    MetArea:
      properties: 
        metAreaCode:
          $ref: '#/components/schemas/MetAreaCode'
      required: [metAreaCode]
    
    MetAreaCode:
      type: integer
      format: int32
      minimum: 1
      maximum: 21
      
    MetCoastalWarningArea:
      properties: 
        subjectIndicator:
          $ref: '#/components/schemas/SubjectIndicator'          
        metAreaCode:
          $ref: '#/components/schemas/MetAreaCode'
        coastalWarningAreaCode:
          type: string
          pattern: '[a-zA-Z]'
      required: [subjectIndicator, metAreaCode, coastalWarningAreaCode]

    NavCoastalWarningArea:
      properties: 
        subjectIndicator:
          $ref: '#/components/schemas/SubjectIndicator'          
        navAreaCode:
          $ref: '#/components/schemas/NavAreaCode'
        coastalWarningAreaCode:
          type: string
          pattern: '[a-zA-Z]'
      required: [subjectIndicator, navAreaCode, coastalWarningAreaCode]          

    SubjectIndicator:
      type: string
      enum: 
      - NAVIGATIONAL_WARNINGS
      - METEOROLOGICAL_WARNINGS
      - ICE_REPORTS
      - SAR_INFO_AND_PIRACY_WARNINGS
      - METEOROLOGICAL_FORECASTS
      - NOT_USED
      - SATNAV_MESSAGES
      - OTHER_ELECTRONIC_NAVAID_MESSAGES
      - OTHER_NAVIGATIONAL_WARNINGS
      - PILOT_SERVICE_MESSAGES
      - AIS
      - LORAN_MESSAGES
      - SPECIAL_SERVICES_V
      - SPECIAL_SERVICES_W
      - SPECIAL_SERVICES_X
      - SPECIAL_SERVICES_Y
      - NO_MESSAGES_ON_HAND
      description: |
        Subject indicator associated with a Coastal Warning
                    
    Repetition:
      type: object
      properties:
        number: 
          $ref: '#/components/schemas/NumRepetitions'
        intervalHours: 
          $ref: '#/components/schemas/IntervalHours'
      required: [number, intervalHours] 
      
    NumRepetitions:
      description: |
        the number of non-echo repeats of a broadcast (so total number of broadcasts not 
        including echoes will be that number plus one being the initial broadcast)
      type: string
      enum: [ONCE, TWICE, TILL_CANCELLED]
      
    IntervalHours:
      type: integer
      format: int32
      enum: [1,2,3,4,5,6,12,18,24,30,36,48,60,72,96,120]  
      description: |
        The time gap between broadcasts of the same MSI.   
        The satellite service provider documentation should be 
        consulted to determine what values are supported and 
        under what criteria.      
            
    ContinuationToken:
      type: string
      minLength: 1
      maxLength: 4096
      description: |
        Indicates to the server the starting point of the next page 
        of results. The token is not expected to be anywhere near as
        long as 4096 characters but good to put an upper bound on it. 
      example: 10
      
##########################################
### End of egc-api, start of unit tests
##########################################      
            
    Nested:
      type: object
      properties:
        first: 
          type: object
          properties: 
            first2: 
              type: object
              properties:
                first3: 
                  type: string
            second2:
              type: array
              items: 
                type: object
                properties:
                  partNumber: 
                    type: integer
                    format: int32
                required: [partNumber]
        second:
          type: string
          
    Thing:
      oneOf:
      - $ref: '#/components/schemas/ThingMember1'
      - $ref: '#/components/schemas/ThingMember2'
      
    ThingMember1:
      type: object
      properties:
        name:
          type: string
      required: [name]
      
    ThingMember2:
      type: integer
      format: int32
    
    Thing2:
      type: object
      properties:
        stuff:
          oneOf:
          - type: string
          - type: integer
            format: int32          

    Simple:
      type: string
      
    SimpleWithConstraints:
      type: string
      minLength: 4
      maxLength: 255
      pattern: '[a-b0-9]*'
      
      
    ArraySimple:
      type: array
      items:
        type: integer
        format: int32
        
    ArrayComplex:
      type: array
      items: 
        type: object
        properties:
          firstName: 
            type: string
          secondName:
            type: string
        required: [firstName]
     
    Vehicle:
      oneOf: 
      - $ref: '#/components/schemas/Car'
      - $ref: '#/components/schemas/Bike'
      discriminator:
        propertyName: vehicleType
        mapping: 
          car: '#/components/schemas/Car'
          bike: '#/components/schemas/Bike'

    HasWheels:
      oneOf: 
      - $ref: '#/components/schemas/Car'
      - $ref: '#/components/schemas/Bike'
      discriminator:
        propertyName: wheelsType
        mapping: 
          four: '#/components/schemas/Car'
          two: '#/components/schemas/Bike'
          
    Car:
      type: object
      properties:
        vehicleType:
          type: string
        wheelsType:
          type: string
      required: [vehicleType, wheelsType]
          
    Bike:
      type: object
      properties:
        vehicleType:
          type: string
        wheelsType:
          type: string
        colour:
          type: string
      required: [vehicleType, wheelsType, colour]
      
    Shape:
      oneOf:
      - $ref: '#/components/schemas/Oval'
      - $ref: '#/components/schemas/Square'
      discriminator:
        propertyName: shapeType
        mapping: 
          oval: '#/components/schemas/Oval'
          square: '#/components/schemas/Square'
          
    Oval:
      type: object
      properties:
        shapeType:
          type: string
      required: [shapeType]
      
    Square:
      type: object
      properties:
        shapeType:
          type: string
      required: [shapeType]      
      
    OneOfUsesConstraints:
      oneOf:
      - $ref: SmallInt
      - $ref: LargeInt
      
    SmallInt:
      type: integer
      format: int32
      minimum: 0
      maximum: 100
      
    LargeInt:
      type: integer
      format: int32
      minimum: 100
      
    SimpleLong:
      type: integer
      format: int64
      
    SimpleInt:
      type: integer
      format: int32
      
    SimpleInteger:
      type: integer
      
    SimpleFloat:
      type: number
      format: float
      
    SimpleDouble:
      type: number
      format: double
      
    SimpleString:
      type: string
      
    SimpleDateTime:
      type: string
      format: date-time
      
    SimpleDate:
      type: string
      format: date
    
    SimpleTime:
      type: string
      format: time
      
    SimpleBoolean:
      type: boolean
      
    SimpleByteArray:
      type: string
      format: byte
      
    SimpleBinary:
      type: string
      format: binary
      
    PropertyBytesRequired:
      type: object
      properties:
        one: 
          type: string
          format: byte
        two:
          type: string
          format: binary
      required: [one, two]      

    PropertyBytesNotRequired:
      type: object
      properties:
        one: 
          type: string
          format: byte
        two:
          type: string
          format: binary
      
    SimpleIntegerArray:
      type: array
      items: 
        type: integer
        
    ArrayOfComplexType:
      type: array
      items: 
        type: object
        properties:
          name:
            type: string
        required: [name]
        
    ArrayOfOneOf:
      type: array
      items:
        oneOf:
        - type: boolean
        - type: integer 
          format: int32

    ArrayOfOneOfString:
      type: array
      items:
        oneOf:
        - type: string
        - type: integer 
          format: int32
          
    ObjectAllOptionalFields:
      type: object
      properties:
        str: 
          type: string
        num:
          type: integer
          format: int32
          
    ObjectNoOptionalFields:
      type: object
      properties:
        label: 
          type: string
        num:
          type: integer
          format: int32
      required: [label, num]
      
    ######################################
    ## polymorphism, no mapping specified
    ######################################
    Shape2:
      oneOf:
      - $ref: '#/components/schemas/Oval2'
      - $ref: '#/components/schemas/Square2'
      discriminator:
        propertyName: shapeType
          
    Oval2:
      type: object
      properties:
        shapeType:
          type: string
      required: [shapeType]
      
    Square2:
      type: object
      properties:
        shapeType:
          type: string
      required: [shapeType]   
      
    ######################################
    ## polymorphism, discriminated using 
    ## singleton enums
    ######################################      
    Shape3:
      oneOf:
      - $ref: '#/components/schemas/Oval3'
      - $ref: '#/components/schemas/Square3'
      discriminator:
        propertyName: shapeType
        mapping: 
          oval: '#/components/schemas/Oval3'
          square: '#/components/schemas/Square3'
          
    Oval3:
      type: object
      properties:
        shapeType:
          type: string
          enum: [oval]
      required: [shapeType]
      
    Square3:
      type: object
      properties:
        shapeType:
          type: string
          enum: [square]
      required: [shapeType]          
      
    ######################
    ## refs
    ######################
    
    Ref:
      $ref: '#/components/schemas/SimpleInteger'
      
    PropertyRef:
      type: object
      properties:
        first: 
          $ref: '#/components/schemas/SimpleInteger'
      required: [first]
      
    PropertyRefOptional:
      type: object
      properties:
        first: 
          $ref: '#/components/schemas/SimpleInteger'
      
    SimpleEnum:
      type: string
      enum: [hello,there,you]    
    
    SingletonEnum:
      type: string
      enum: [hello]
      
    MinMaxLength:
      type: object
      properties:
        first: 
          type: string
          minLength: 1
          maxLength: 3
        second:
          type: string
          minLength: 2
          maxLength: 3
      required: [first] 
      
    Pattern:
      type: object
      properties:
        first: 
          type: string
          pattern: 'a.*'
        second:
          type: string
          pattern: 'b.*'
      required: [first]  
      
    MinMaxInteger:
      type: integer
      format: int32
      minimum: 2
      maximum: 4

    MinMaxDouble:
      type: number
      format: double
      minimum: 2.1
      maximum: 4.5
      
    ExclusiveMinMaxInteger:
      type: integer
      format: int32
      minimum: 2
      maximum: 4
      exclusiveMinimum: true
      exclusiveMaximum: true
               
    NamesWithSpaces:
      type: object
      properties:
        'the name': 
          type: string
                     
    MinMaxItems:
      type: array
      items:
        type: integer
        format: int32
      minItems: 2
      maxItems: 4          

    MinMaxItemsObjectRef:
      type: object
      properties:
        list:
          type: array
          items:
            $ref: '#/components/schemas/MinMaxInteger'
          minItems: 2
          maxItems: 4     
      
    ForeignLanguageEnum:
      type: string
      enum:
      - هجري
      - ميلادي
      maxLength: 7
      example: هجري      
      
    NestedNameCollision:
      type: object
      properties:
        collision: 
          type: object
          properties:
            a: 
              type: string
        other: 
          type: object
          properties:
            collision:
              type: object
              properties:
                b: 
                  type: string
                  
    EnumCollision:
      type: string
      enum: ['a b','a  b','a   b']      
      
    EnumRepeated:
      type: string
      enum: ['a','a','b']    
      
    AllOfRefs:
      allOf:
      - $ref: '#/components/schemas/Oval2'
      - $ref: '#/components/schemas/Square2'    
              
    EnumProperty:
      type: object
      properties:
        name: 
          type: string
          enum: [hi,there,you]    
          
    PropertyNotRequired:
      type: object
      properties:
        name: 
          type: string      
          
    PropertyAnonymous:
      type: object
      properties:
       name: 
         type: object
         properties:
           first:
             type: string
           second:
             type: string    
                 
    Pet:
      type: object
      properties:
        description: 
          type: string
      required: [description]
            
    AllOfArray:
      allOf:
      - type: object
        properties:
          items:
            type: array
            items:
              $ref: '#/components/schemas/Pet'
      - $ref: '#/components/schemas/Dog'
            
    Dog:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          breed:
            type: string
            enum: [poodle, cross]
            
    Breeding:
      type: object
      properties:
        breeder: 
          type: string
        breed:
          $ref: '#/components/schemas/DogBreed'
      required: [breeder, breed]
          
    DogBreed: 
      type: string
      enum: [poodle, cross]

    Dog2:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - $ref: '#/components/schemas/Breeding'            
              
    ArrayInProperty:
      type: object
      properties:
        counts: 
          type: array
          items: 
            type: integer
            format: int32
      required: [counts]
      
    ArrayOfObjectInProperty:
      type: object
      properties:
        records: 
          type: array
          items: 
            type: object
            properties:
              number:
                type: integer
                format: int32
              description: 
                type: string
            required: [number, description]
      required: [records]
      
    Table:
      type: array
      items: 
        type: array
        items: 
          type: integer
          format: int32

    ## Name collision (cannot hide a class name in the heirarchy)         
    Items:
      type: object
      properties:
        items:
          type: array
          description: An arraylist of all the items.
          items:
            type: string 
            
    External:
      $ref: './fragment.yml#/components/schemas/Exter'
      
    SingleOptional:
      type: object
      properties:
        single:
          type: integer
          format: int32
          
    SingleNotOptional:
      type: object
      properties:
        single:
          type: integer
          format: int32
      required: [single]
          
    AdditionalProperties:
      type: object
      properties:
        name:
          type: string
        age:
          type: integer
          format: int32
      additionalProperties:
        type: integer
        minimum: 0        
                
    AdditionalPropertiesTrue:
      type: object
      properties:
        name: 
          type: string
        age: 
          type: integer
          format: int32
      additionalProperties: true
      
    AdditionalPropertiesOnly:
      type: object
      additionalProperties:
        type: boolean
        
    AdditionalPropertiesOnProperty:
      type: object
      properties:
        props:
          type: object
          additionalProperties:
            type: integer       

    AdditionalPropertiesNested:
      type: object
      additionalProperties:
        type: object
        additionalProperties:
          type: string                           
      
    UntypedObject:
      type: object
      
    AnyObjectProperty:
      type: object
      properties:
        stuff: {}
        
    AnyObjectProperty2:
      type: object
      properties:
        stuff: {}     
        other: 
          type: string
      required: [other, stuff]   

    AnyObjectArrayProperty:
      type: object
      properties:
        stuff: 
          type: array
          items: {}   
        
    AnyObjectArrayProperty2:
      type: object
      properties:
        stuff: 
          type: array
          items: {}   
        other: 
          type: string
      required: [other, stuff]     
      
    TwoMaps:
      type: object
      properties:
        stuff: {}
        other: {}

    ## member class naming and name collision test 
    PropertyStartsWithUnderscore:
      type: object
      properties:
        _type:
          type: string
          enum: [hello, there]        
        type: 
          type: integer
          format: int32
          enum: [1,2,4,8]
          
    _has_underscores:
      type: object
      properties:
        the_thing:
          type: string
          enum: [helo, plane]   
          
    ArbitraryPrecisionNumber:
      type: number
      x-openapi-codegen-arbitrary-precision: true
      minimum: 12.5
      maximum: 21.7
      
    ArbitraryPrecisionInteger:
      type: integer
      x-openapi-codegen-arbitrary-precision: true
      
    ArbitraryPrecisionEnum:
      type: integer
      enum: [1, 2, 4, 8]
      x-openapi-codegen-arbitrary-precision: true
      
    BlankStringEnum:
      type: string
      enum: ["", "yes", "no"]
      
    AnonymousOneOf:
      oneOf:
      - type: object
        properties: 
          name:
            type: string
        required: [name]
      - type: object
        properties: 
          nom:
            type: string
        required: [nom]
        
    AnonymousOneOfDiscriminated:
      oneOf:
      - type: object
        properties: 
          idName:
            type: string
          name:
            type: string
        required: [idName, name]
      - type: object
        properties: 
          idName:
            type: string
          nom:
            type: string
        required: [idName,nom]        
      discriminator:
        propertyName: idName
        type: string      
        
    2StartWithInteger:
      type: string    
      
    NullableExample:
      type: object
      properties: 
        req:
          type: integer
          format: int32
          nullable: true    
        a: 
          type: integer
          format: int64
        notReq:
          type: string
          minLength: 4
          nullable: true
        b: 
          type: string
          enum: [hello, there]
      required: [req, a, b]
      
    NullableSingle:
      type: object
      properties:
        name:
          type: string
          nullable: true
          
    NullableStringEnum:
      type: string
      enum: [hello, there, null]
      nullable: true
      
    NullableStringEnumObject:
      type: object
      properties:
        thing: 
          $ref: '#/components/schemas/NullableStringEnum'
      required: [thing]
    
    NullableIntegerEnum:
      type: integer
      format: int32
      enum: [1, 2, null, 3]
      nullable: true
      
    ## this means that {thing: null} is possible (not that the Map can have null values) 
    NullableMapProperty:
      type: object
      properties:
        thing:
          nullable: true
          
    NullableMapPropertyNotAlone:
      type: object
      properties:
        thing:
          nullable: true
        other:
          type: string          
          
    NullableMapPropertyReq:
      type: object
      properties:
        thing:
          nullable: true
      required: [thing]     
      
    NullableMapPropertyArrayReq:
      type: object
      properties:
        thing:
          type: array
          items:
            nullable: true
      required: [thing]   
      
    NullableMapPropertyArrayNotReq:
      type: object
      properties:
        thing:
          type: array
          items:
            nullable: true
            
    ArrayNullableItems:
      type: array
      items: 
        type: object
        properties:
          start:
            type: string
          finish:
            type: string
        required: [start, finish]
        nullable: true
            
    AdditionalPropertiesNullable:
      type: object            
      additionalProperties:
        type: string
        nullable: true
        
    DescriptionEscaping:
      type: string
      description: value < 5 chars & an arrow like -->
      
    MapPropertyNotReqNotAlone:
      type: object
      properties:
        first: 
          type: string
        second:
          description: something here

    InputTransform:
      oneOf:
        - $ref: "#/components/schemas/StaticTransform"
      discriminator:
        propertyName: type
        mapping:
          static: "#/components/schemas/StaticTransform"
          
    StaticTransform:
      type: object
      properties:
        value: {}
        type:
          type: string
          enum: [javascript]
      required: [type]  
      
    NullableAdditionalProperties:
      type: object
      properties: 
        files:
          additionalProperties:
            nullable: true
            properties:
              content:
                type: string 
      required: [files]      
    
    MixRequiredAndNotRequiredWithConstraint:
      type: object
      properties:
        a: 
          type: string
          minLength: 3
        b: 
          type: integer
          format: int32
          minimum: 10
      required: [a]

    AnyOfSimpleTypes:
      anyOf:
      - $ref: "#/components/schemas/SmallInt"
      - $ref: "#/components/schemas/LargeInt"
      
    AnyOfConflictingTypes:
      anyOf:
      - type: string
      - type: integer
      
    AnyOfConflictingTypes2:
      anyOf:
      - type: string
      - type: object
        properties:
          name: 
            type: string
        required: [name]
        
    AnyOfObjectExtensions:
      anyOf:
      - type: object
        properties:
          counts: 
            type: array
            items:
              type: integer
              format: int32
        required: [counts]
      - type: object
        properties:
          name: 
            type: string
          counts: 
            type: array
            items:
              type: integer
              format: int32
        required: [name, counts]        
        
    #example from OAS
    PetSearch:
      anyOf:
      - $ref: '#/components/schemas/PetByAge'
      - $ref: '#/components/schemas/PetByType'
      
    PetByAge:
      type: object
      properties: 
        age: 
          type: integer
        nickname: 
          type: string
      required:
        - age
          
    PetByType:
      type: object
      properties:
        pet_type:
          type: string
          enum: [Cat, Dog]
        hunts:
          type: boolean
      required: 
        - pet_type
      additionalProperties: false        
        
    String: 
      type: string
      minLength: 1
      
    StringBadConstraint:
      type: string
      minimum: 1
      maximum: 10
      
    EnumSubs:
      type: string
      enum: [off, on, yes, no, true, false, ok, bad, good]
      
    AnyOfWithNullableMembers:
      anyOf:
        - nullable: true
          type: string
        - nullable: true
          type: number
        - nullable: true
          type: boolean
        - nullable: true
          type: object
        - items:
            type: string
          type: array
          
    EnumOfObjects:
      type: object
      enum:
        - id: 1
          name: LoL
          slug: league-of-legends
        - id: 3
          name: CS:GO
          slug: cs-go

    EnumOfObjectsNamed:
      type: object
      enum:
        - id: 1
          name: LoL
          slug: league-of-legends
        - id: 3
          name: CS:GO
          slug: cs-go          
      x-openapi-codegen-names: [LOL, CSGO]
      
    ListOfNullableConstraints:
      type: array
      items: 
        type: string
        nullable: true
        minLength: 2
        maxLength: 4
        
    BinaryConstraints:
      type: string
      format: binary
      minLength: 2
      maxLength: 2
 
# TODO fix compile failure
#    BinaryConstraintsNullable:
#      type: string
#      format: binary
#      minLength: 2
#      maxLength: 2
#      nullable: true
              
    

      